# Making our code more modular
As we write more and more JavaScript, our code runs the risk of becoming unwieldy.

When we ran into this problem in CSS, we turned to Sass and we were able to solve this issue by creating partials. In JavaScript, we solve this by using _modules_!

## What are modules?

Modules are smallish chunks of code stored in separate files that can be composed together. (Kind of like Lego blocks.) Modules are easier to manage and understand than single files that are hundreds or even thousands of lines long.

Think back to when we were creating our API projects. We had one giant object that had lots of methods and properties stored on it. By the end of your project, it was probably over a hundred lines long. Imagine we were accessing multiple different APIs, or had a few separate applications that we were all trying to store in one file. Yiiiikes.

The separate, small modules are grouped together in a process called _bundling_ so that we can use them on our websites.

## How do we use modules?

Modules aren't natively supported by all browsers. But they are supported by Firefox 63+, so let's take a look at how they work:

Download [learning-modules.zip](https://hychalknotes.s3.amazonaws.com/learning-modules.zip) to follow along.

### Set up 
To start, we need to include a `type` attribute whose value is `module` on our script tag.

```javascript
<script type="module" src="scripts/app.js"></script>
``` 
<!-- Should there be more here? -->

### Building and exporting a module
Let's imagine that we're building a program that requires a couple different kinds of randomization (e.g. random day of the week, random number, random color code, etc.).

We're going to create a module to store our randomizing functions. Let's create a file called `randomizer.js` in our scripts folder. This will be our module.

```bash
- learning-modules
  index.html
  - scripts 
    app.js
    randomizer.js
```

Let's start by writing the randomizing function in `ranodmizer.js` as if it were any other JavaScript file:

```javascript
// randomizer.js

const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];

function getRandomDay() {
  const randomDay = Math.floor(Math.random() * days.length);

  return days[randomDay];
}
```

Awesome! Now we have to find a way to tell JavaScript that we want to be able to use this code in another file.

For that we have the `export` and `default` keywords.

```javascript
// randomizer.js

const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];

export default function getRandomDay() {
  const randomDay = Math.floor(Math.random() * days.length);

  return days[randomDay];
}
```

`export default` tells any files that want to import our `randomizer.js` module that we want them to have access to our `getRandomDay` function.

Note that you can only have **one** default export per module.

Hooray, we made a module! Now we can use it in our main application.

### Importing your modules using 'import'

Let's hop over into `app.js` and imagine that we're beginning to write our application. We want to bring in our randomizer module so we can take advantage of the `getRandomDay` function we wrote.

Now that our functions have been made ready for use in our application with the `export` keyword, we need to bring them in using the `import` keyword!

```javascript
// app.js
import getRandomDay from './randomizer.js';

getRandomDay(); // Wednesday

```

And voila! We now have successfully imported our `getRandomDay` function.

Import allows us to dig into our `randomizer.js` module and pull out whatever was set as our default export (which, if you'll remember, was `getRandomDay`!).

Note: We could rename `getRandomDay` here to anything and it would still grab the function - it doesn't have to match the name of our function inside our module.  

## Importing and Exporting Named Functions

### Exporting Named Functions
Let's say we want to add another function to our module, that prints out a random number between one and one hundred:

```javascript
const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];

export default function getRandomDay() {
  const randomDay = Math.floor(Math.random() * days.length);

  return days[randomDay];
}

function getRandomNumber() {
  return Math.round(Math.random() * 100);
}
```

Since modules are only allowed to have one `export default`, how are we going to export our `getRandomNumber` function? Well, modules support something called `named exports` as well, like this:

```javascript
const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];

export default function getRandomDay() {
  const randomDay = Math.floor(Math.random() * days.length);

  return days[randomDay];
}

export function getRandomNumber() {
  return Math.round(Math.random() * 100);
}
```

When we use the `export` function without the `default` keyword, this is called a `named export`.

### Importing Named Functions

Importing our named export is very similar to importing a default export. It looks like this:

```javascript
// app.js
import { getRandomNumber } from './randomizer.js';

randomNumber(); // Wednesday

```

We place the name of the function that we want to grab from the `randomizer` module inside the curly brackets. The curly bracket syntax is accessible to us through ES6 and is called destructuring.

Now you know how to recognize and implement ES6 modules - we'll see them again when we start digging in to React!

### Additional Resources
* [Let's Learn ES6: Modules](https://www.youtube.com/watch?v=aQr2bV1BPyE) with Ryan Christiani
* [An Intro to Using npm and ES6 Modules for Front End Development](http://wesbos.com/javascript-modules/) An Introduction to ES6 Modules by Wes Bos